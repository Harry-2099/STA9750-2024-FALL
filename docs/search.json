[
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Harry’s Mental Health Study",
    "section": "Introduction",
    "text": "Introduction\nHello, I’m Harry and welcome to my first github pages website. I promise I’m not insane I just wanted to graph something and went with this is corny joke. I am in a MS in Statistics and Data Science program, coming from a business background. My decision to pursue this degree stemmed from my desire to learn the intricacies involved in modern stats and their applications.Topics that particularly excite me are Machine and Statistical Learning as well as the application of these to financial and economic problems."
  },
  {
    "objectID": "mp01.html",
    "href": "mp01.html",
    "title": "Mini Project 1",
    "section": "",
    "text": "This analysis looks to provide some insights on the financial information behind some of the biggest transit agencies in the US. The data set being studied includes massive systems like the NYC Metro and also lesser used systems in states like Hawaii and Oklahoma.\n\n\n\nAfter loading the data certain column names and row values need to be changed for syntactic reasons and ease of understanding. Firstly, changing the column UZA Name to metro_area will allow for syntactic ease, and a more intuitive label.\n\nUSAGE &lt;- inner_join(TRIPS, MILES) |&gt;\n    mutate(`NTD ID` = as.integer(`NTD ID`))\n\nJoining with `by = join_by(`NTD ID`, Agency, `UZA Name`, Mode, `3 Mode`,\nmonth)`\n\n    sample_n(USAGE, 1000) |&gt; \n    rename(\"metro_area\" = \"UZA Name\") %&gt;% #renaming UZA\n    mutate(month=as.character(month))\n\n# A tibble: 1,000 × 8\n   `NTD ID` Agency                 metro_area Mode  `3 Mode` month    UPT    VRM\n      &lt;int&gt; &lt;chr&gt;                  &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1    20113 Regional Transit Serv… Rochester… MB    Bus      2016… 1.33e6 417338\n 2    50019 City of Middletown     Middletow… DR    Bus      2008… 7.18e2   4172\n 3    30111 Washington County Tra… Pittsburg… MB    Bus      2014… 1.53e3   6581\n 4    20018 Central New York Regi… Syracuse,… DR    Bus      2019… 6.92e3 100968\n 5    60102 Concho Valley Transit… San Angel… MB    Bus      2008… 1.65e4  32176\n 6    50166 Clermont County, Ohio  Cincinnat… MB    Bus      2020… 7.2 e2   8974\n 7    50113 Pace, the Suburban Bu… Chicago, … VP    Bus      2011… 1.47e5 795247\n 8    40093 City of Greensboro     Greensbor… MB    Bus      2011… 3.34e5 164105\n 9    20004 Niagara Frontier Tran… Buffalo, … MB    Bus      2017… 1.73e6 665018\n10        7 Lane Transit District  Eugene, OR MB    Bus      2020… 1.15e3 124987\n# ℹ 990 more rows\n\n\nThe second section will be “re-coding” the Mode date in the dataframe. Since the data originally had codes like “HR” for Heavy Rail, or “FB” for Ferry Boat it will be hard for someone ignorant of these codes to understand the meaning behind them. So we will find all the distinct values, search their meanings, and then rename those values. The results will be displayed a Data Table using the DT library\n\n  distinct_modes&lt;- USAGE %&gt;% distinct(Mode)\n \n   USAGE &lt;- USAGE |&gt;\n     mutate(Mode=case_when(\n          Mode == \"HR\" ~ \"Heavy Rail\", \n          Mode == \"DR\"~\"Demand Response\",\n          Mode == \"FB\"~\"Ferryboat\",\n          Mode == \"MB\"~\"Bus\",\n          Mode == \"SR\"~\"Streetcar Rail\",\n          Mode == \"TB\"~\"Trolleybus\",\n          Mode == \"VP\"~\"Vanpool\",\n          Mode == \"CB\"~\"Commuter Bus\",\n          Mode == \"RB\"~\"Bus Rapid Transit\",\n          Mode == \"LR\"~\"Light Rail\",\n          Mode == \"YR\"~\"Hybrid Rail\",\n          Mode == \"MG\"~\"Monorail Automated Guideway\",\n          Mode == \"CR\"~\"Commuter Rail\",\n          Mode == \"AR\"~\"Alaska Railroad\",\n          Mode == \"TR\"~\"Aerial Tramway\",\n          Mode == \"IP\"~\"Inclined Plane\",\n          Mode == \"PB\"~\"Publico\",\n          Mode == \"CC\"~\"Cable Car\",\n          TRUE~\"Unknown\"))\n    Use_table &lt;- DT::datatable(head(USAGE, 5000))\n\n\n\n\n\n\n\n\n\n\n\n\nUsing the arrange function we can sort the data based on a ascending or descending order of a specified value. Using arrange combined with desc function we get the all the VRM values starting from highest to lowest. The corresponding agency will be the answer.\n\nMax_VRM &lt;- USAGE %&gt;% \n    select(VRM,Agency) %&gt;%\n    arrange(desc(VRM)) %&gt;% \n    head(1)\n    print(Max_VRM)\n\n# A tibble: 1 × 2\n       VRM Agency                   \n     &lt;dbl&gt; &lt;chr&gt;                    \n1 30882144 MTA New York City Transit\n\n\n\n\n\nUsing the same idea as the previous question, this time combining it with the group_by function will allow us to find the answer. The group_by function creates “groups” of a given variable to then perform some action to those groups. In this case we will group by the mode and then sum up the VRM for each mode. This method will provide the answer “Bus”\n\nvrm_by_mode &lt;- USAGE %&gt;% \n    select(VRM,Mode) %&gt;%\n    group_by(Mode) %&gt;% \n    summarise(Total = sum(VRM)) %&gt;% \n    arrange(desc(Total))\n    print(vrm_by_mode)\n\n# A tibble: 18 × 2\n   Mode                              Total\n   &lt;chr&gt;                             &lt;dbl&gt;\n 1 Bus                         49444494088\n 2 Demand Response             17955073508\n 3 Heavy Rail                  14620362107\n 4 Commuter Rail                6970644241\n 5 Vanpool                      3015783362\n 6 Light Rail                   2090094714\n 7 Commuter Bus                 1380948975\n 8 Publico                      1021270808\n 9 Trolleybus                    236840288\n10 Bus Rapid Transit             118425283\n11 Ferryboat                      65589783\n12 Streetcar Rail                 63389725\n13 Monorail Automated Guideway    37879729\n14 Hybrid Rail                    37787608\n15 Alaska Railroad                13833261\n16 Cable Car                       7386019\n17 Inclined Plane                   705904\n18 Aerial Tramway                   292860\n\n\n\n\n\nTo answer this the use of the filter function is required. The filter function will remove all the data that doesn’t agree with the filter statement, allowing for more specific analysis. Filtering for a May 2024 date and a NYC MTA Agency Subway will give the answer, but first some data manipulating is required. Creating a year and month column with the lubridate library, allows for quick and easy date time analysis and will come in handy, making future analysis streamlined. After doing so the previous techniques are used.\n\n  typeof(USAGE$month)#checking the type of column month is\n\n[1] \"double\"\n\nlibrary(lubridate)\n  USAGE$month &lt;- ymd(USAGE$month) #changing to date format\n  USAGE &lt;- USAGE %&gt;% \n     rename(\"trips\"=UPT) %&gt;% #renaming the UPT(Unlinked passenger trips)- to trips\n     rename(\"date\"=month) %&gt;%  \n     mutate(\"year\"= year(date)) %&gt;%\n     mutate('month'= month(date))\n  nyc_trips &lt;- USAGE %&gt;% \n    filter(Agency == \"MTA New York City Transit\" & Mode ==\"Heavy Rail\")%&gt;% \n    filter(year==2024 & month == 5) %&gt;% \n    summarise(may_total=sum(trips))\n    print(nyc_trips)\n\n# A tibble: 1 × 1\n  may_total\n      &lt;dbl&gt;\n1 180458819\n\n\n\n\n\nUsing all the techniques from the previous questions, along with the pull method to give a singular value will provide an answer for this question. After pulling the data for both cases we can simply find the difference.\n\n  nyc_monthly &lt;- USAGE %&gt;% #this table provides info that might be useful later on\n    filter(Agency == 'MTA New York City Transit' & Mode == 'Heavy Rail') %&gt;% \n    group_by(year, month) %&gt;%                       \n    mutate(total_vrm = sum(VRM)) %&gt;% \n    mutate(total_trips = sum(trips)) %&gt;%\n    select(year,month,total_trips,total_vrm)\n   vrm_2019 &lt;- nyc_monthly %&gt;%\n    filter(year == 2019 & month == 4) %&gt;% \n    pull(total_vrm)\n  \n  vrm_2020 &lt;- nyc_monthly %&gt;%\n    filter(year == 2020 & month == 4) %&gt;% \n    pull(total_vrm)\n  \n  print(\"VRM Difference\")\n\n[1] \"VRM Difference\"\n\n  vrm_2019-vrm_2020 #difference in Vehicle Revenue Miles\n\n[1] 12200677\n\n  trips_2019 &lt;- nyc_monthly %&gt;%\n    filter(year == 2019 & month == 4) %&gt;% \n    pull(total_trips)\n  \n  trips_2020 &lt;- nyc_monthly %&gt;%\n    filter(year == 2020 & month == 4) %&gt;% \n    pull(total_trips)\n  print(\"Trips Difference\")\n\n[1] \"Trips Difference\"\n\n  trips_2019-trips_2020 #decrease in trips\n\n[1] 211969660\n\n\n\n\n\n\n\nUsing a combintion of techniques like filtering, summarize, as well as grouping by the month column will provide the answer.\n\n     USAGE %&gt;% \n     filter(year == 2023) %&gt;% \n     select(year,month,VRM) %&gt;% \n     group_by(month) %&gt;% \n     summarise(total_vrm = sum(VRM)) %&gt;% \n     arrange(desc(total_vrm))\n\n# A tibble: 12 × 2\n   month total_vrm\n   &lt;dbl&gt;     &lt;dbl&gt;\n 1     8 422002435\n 2    10 420684229\n 3     3 413311032\n 4     5 407605645\n 5    11 402542477\n 6     6 400875583\n 7    12 399428041\n 8     7 398685473\n 9     9 398172153\n10     1 389141732\n11     4 386876164\n12     2 361882307\n\n\n\n\n\nSimilarly with this question grouping by year and computing the desired value, using mutate this time, gives us the answer. We can also plot this to see some yearly trends using ggplot.\n\n  yearly_trips &lt;- USAGE %&gt;% \n     group_by(year) %&gt;% \n     mutate(total_trips = sum(trips)) %&gt;%\n     mutate(avg_trip_day = total_trips/365) %&gt;% \n     select(year,total_trips,avg_trip_day) %&gt;% \n     arrange(desc(total_trips)) %&gt;% \n     distinct(year,total_trips,avg_trip_day)\n     #plotting\n     ggplot(yearly_trips,aes(x= year,y=avg_trip_day))+\n       geom_line(color = 'blue')+\n       labs(title = \"Trends in Avg Trips Per Day\", y = \"Unlinked Trips\",x = \"Years\")+\n       theme_minimal()\n\n\n\n\n\n\n\n\nPredictably, there is a huge drop in 2020 in average trips.\n\n\n\nTo answer this we can group by metro area and then summarize for the mean of area. After generating a dataframe with these values we can see Chicago was the highest followed by Las Vegas area, and the lowest was Cheyenne,WY. We can also create a bar graph of the top 10 areas to visualize this clearly. Using the aes (aesthetic) function with fill = metro_area allows for a colorful representation of each chart. This method creates a legend we don’t need so we set show.legend = FALSE. The element text function allows for the X label to be angled and positioned correctly for long label names.\n\n   USAGE &lt;- USAGE %&gt;% rename(\"metro_area\" = \"UZA Name\")#had to rerun this code\n \n   trips_by_area &lt;- USAGE %&gt;% \n        select(year,metro_area,trips) %&gt;% \n        group_by(metro_area) %&gt;% \n        summarise(avg_trips = mean(trips)) %&gt;% \n        arrange(desc(avg_trips)) %&gt;% \n        head(10)\n\n    ggplot(trips_by_area,aes(x = metro_area,y = avg_trips))+\n        geom_bar(stat = 'identity',aes(fill = metro_area),color = \"red\",show.legend = FALSE)+\n        theme_minimal()+\n        theme(axis.text.x = element_text(angle = 45, hjust = 1,vjust = 1))+\n        labs(title = \"Average Trips by City\",y= \"Unlinked Passenger Trips\", x= \"Metro Area\")\n\n\n\n\n\n\n\n\n\n\n\n\nThis task pertains to joining two tables to create a Usage and financial table. We will join on the keys NTD ID and Mode. Since the mode is different in the financial table (recall it was altered for usability) it must also be changed. Grouping by NTD ID and Mode allows for us answer the questions in Task 6 which requires transportation agency and method to be combined, since each agency has its own unique ID this is exactly the same thing.\n\n  USAGE_2022_ANNUAL &lt;- USAGE %&gt;% \n        filter(year == 2022) %&gt;% \n        select('NTD ID',Mode,Agency,metro_area,trips,VRM) %&gt;% \n        group_by(`NTD ID`,Mode) %&gt;% \n        summarise(annual_trips = sum(trips),annual_vrm = sum(VRM)) %&gt;% \n        ungroup()\n\n`summarise()` has grouped output by 'NTD ID'. You can override using the\n`.groups` argument.\n\n      Financials &lt;- Financials |&gt;\n     mutate(Mode=case_when(\n          Mode == \"HR\" ~ \"Heavy Rail\", \n          Mode == \"DR\"~\"Demand Response\",\n          Mode == \"FB\"~\"Ferryboat\",\n          Mode == \"MB\"~\"Bus\",\n          Mode == \"SR\"~\"Streetcar Rail\",\n          Mode == \"TB\"~\"Trolleybus\",\n          Mode == \"VP\"~\"Vanpool\",\n          Mode == \"CB\"~\"Commuter Bus\",\n          Mode == \"RB\"~\"Bus Rapid Transit\",\n          Mode == \"LR\"~\"Light Rail\",\n          Mode == \"YR\"~\"Hybrid Rail\",\n          Mode == \"MG\"~\"Monorail Automated Guideway\",\n          Mode == \"CR\"~\"Commuter Rail\",\n          Mode == \"AR\"~\"Alaska Railroad\",\n          Mode == \"TR\"~\"Aerial Tramway\",\n          Mode == \"IP\"~\"Inclined Plane\",\n          Mode == \"PB\"~\"Publico\",\n          Mode == \"CC\"~\"Cable Car\",\n          TRUE~\"Unknown\"))\n      \n      USAGE_AND_FINANCIALS &lt;- left_join(USAGE_2022_ANNUAL, \n           Financials, \n           join_by(`NTD ID`, Mode)) |&gt;\n           drop_na()\n\n\n\n\n\n\nUsing Group_by and summarize with max( ) we get the answer New York MTA and Heavy Rail.\n\n      USAGE_AND_FINANCIALS %&gt;% \n        group_by(`Agency Name`,`Mode`) %&gt;% \n        summarise(max_trips = max(annual_trips)) %&gt;% \n        arrange(desc(max_trips)) %&gt;% \n        head(1)\n\n# A tibble: 1 × 3\n# Groups:   Agency Name [1]\n  `Agency Name`             Mode        max_trips\n  &lt;chr&gt;                     &lt;chr&gt;           &lt;dbl&gt;\n1 MTA New York City Transit Heavy Rail 1793073801\n\n\n\n\n\nUsing mutate to create another calculated column with the Fare Box Ratio formula we get the answer, Vanpool in the Central Kentucky agency. This makes sense as vanpool is essentially car pooling in small vehicles like vans and small buses for shorter distances. This allows for lower costs then other modes like for example Heavy Rail, which require lots of maintenance and overhead.\n\n      USAGE_AND_FINANCIALS&lt;-USAGE_AND_FINANCIALS %&gt;% \n         group_by(`Agency Name`,`Mode`) %&gt;% \n         mutate(fare_box_recovery = `Total Fares`/Expenses) %&gt;%\n         arrange(desc(fare_box_recovery))\n         print(USAGE_AND_FINANCIALS)\n\n# A tibble: 1,132 × 8\n# Groups:   Agency Name, Mode [1,130]\n   `NTD ID` Mode    annual_trips annual_vrm `Agency Name` `Total Fares` Expenses\n      &lt;dbl&gt; &lt;chr&gt;          &lt;dbl&gt;      &lt;dbl&gt; &lt;chr&gt;                 &lt;dbl&gt;    &lt;dbl&gt;\n 1    40191 Vanpool         9640      94027 Transit Auth…         97300    40801\n 2    40034 Vanpool       395004    3091052 County of Mi…       1987879  1191874\n 3    90233 Vanpool        70093     462346 Yuma County …        411216   279585\n 4    20190 Ferryb…      3757873     504037 Port Imperia…      33443241 23417248\n 5    11239 Ferryb…       878728     188694 Hyannis Harb…      25972659 18383764\n 6    11238 Ferryb…        96707      56980 Bay State LLC       6287351  4672351\n 7    20169 Commut…       403646    1259602 Trans-Bridge…      11325199  8495611\n 8    40001 Inclin…       481957      20128 Chattanooga …       3005198  2290714\n 9    66339 Vanpool       118780    1748901 New Mexico D…        757574   588830\n10       12 Vanpool       189684    1582484 Municipality…       1400709  1105911\n# ℹ 1,122 more rows\n# ℹ 1 more variable: fare_box_recovery &lt;dbl&gt;\n\n\n\n\n\nSimilarly we can answer this question.\n\n       USAGE_AND_FINANCIALS %&gt;% \n           group_by(`Agency Name`,`Mode`) %&gt;% \n           mutate(expenses_per_trip = Expenses/annual_trips) %&gt;% \n           select(`Agency Name`,Mode,expenses_per_trip) %&gt;% \n           arrange(expenses_per_trip)\n\n# A tibble: 1,132 × 3\n# Groups:   Agency Name, Mode [1,130]\n   `Agency Name`                                         Mode  expenses_per_trip\n   &lt;chr&gt;                                                 &lt;chr&gt;             &lt;dbl&gt;\n 1 North Carolina State University                       Bus                1.18\n 2 Anaheim Transportation Network                        Bus                1.28\n 3 Valley Metro Rail, Inc.                               Stre…              1.49\n 4 University of Iowa                                    Bus                1.54\n 5 Chatham Area Transit Authority                        Ferr…              1.60\n 6 Texas State University                                Bus                2.05\n 7 South Florida Regional Transportation Authority       Bus                2.27\n 8 University of Georgia                                 Bus                2.31\n 9 Hillsborough Area Regional Transit Authority          Stre…              2.45\n10 University of Michigan Parking and Transportation Se… Bus                2.52\n# ℹ 1,122 more rows\n\n\nIndicates that buses have a low cost per person.\n\n\n\nIn this question, an extra step will be taken for later use to both easily answer more questions and also effectively produce some visualizations based on the given problems. Firstly, using mutate to calculate Fares/ UPT(Trips) grouped by the agency and mode will be enough to answer the question. The second additional step will be to make a new column that contains both the agency and the mode in one column. This will make it easier to get this information, and also will allow use to graph these grouped problems. To do this the use of the stringr library. This library is used for manipulating strings, and in this case it will be used to combine the 2 strings in both agent and mode columns.\n\nlibrary(stringr)\n       fare_per_trip &lt;- USAGE_AND_FINANCIALS %&gt;% \n           group_by(`Agency Name`,`Mode`) %&gt;% \n           mutate(fares_per_trip = `Total Fares`/annual_trips) %&gt;% \n           mutate(Agent_Mode = str_c(`Agency Name`,Mode, sep = \", \")) %&gt;% #joining the col strings with a comma and space\n           arrange(desc(fares_per_trip)) %&gt;% \n           select(`Agency Name`,fares_per_trip,Mode,Agent_Mode) %&gt;%\n           head(10)\n       print(fare_per_trip)\n\n# A tibble: 10 × 4\n# Groups:   Agency Name, Mode [10]\n   `Agency Name`                                 fares_per_trip Mode  Agent_Mode\n   &lt;chr&gt;                                                  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     \n 1 Altoona Metro Transit                                  660.  Dema… Altoona M…\n 2 Alaska Railroad Corporation                            153.  Alas… Alaska Ra…\n 3 Bay State LLC                                           65.0 Ferr… Bay State…\n 4 Central Pennsylvania Transportation Authority           50.2 Dema… Central P…\n 5 Hampton Jitney, Inc.                                    41.3 Comm… Hampton J…\n 6 County of Placer                                        38.8 Comm… County of…\n 7 Audubon Area Community Services, Inc.                   37.4 Dema… Audubon A…\n 8 Lane Transit District                                   34.0 Dema… Lane Tran…\n 9 Pennsylvania Department of Transportation               32.3 Comm… Pennsylva…\n10 Hyannis Harbor Tours, Inc.                              29.6 Ferr… Hyannis H…\n\n\nWith the new column, removing agent and mode columns.\n\n  fare_per_trip %&gt;% \n     ungroup() %&gt;% \n     select(Agent_Mode,fares_per_trip)\n\n# A tibble: 10 × 2\n   Agent_Mode                                                     fares_per_trip\n   &lt;chr&gt;                                                                   &lt;dbl&gt;\n 1 Altoona Metro Transit, Demand Response                                  660. \n 2 Alaska Railroad Corporation, Alaska Railroad                            153. \n 3 Bay State LLC, Ferryboat                                                 65.0\n 4 Central Pennsylvania Transportation Authority, Demand Response           50.2\n 5 Hampton Jitney, Inc., Commuter Bus                                       41.3\n 6 County of Placer, Commuter Bus                                           38.8\n 7 Audubon Area Community Services, Inc., Demand Response                   37.4\n 8 Lane Transit District, Demand Response                                   34.0\n 9 Pennsylvania Department of Transportation, Commuter Rail                 32.3\n10 Hyannis Harbor Tours, Inc., Ferryboat                                    29.6\n\n\nAs you can see it is very simple to read\nSince the Altoona per trip price is so high, some additional analysis is required.\n\n  USAGE %&gt;%\n    group_by(Mode,Agency) %&gt;% \n    filter(Agency == 'Altoona Metro Transit'& year == 2022) %&gt;% \n    filter(Mode== \"Demand Response\") %&gt;%\n    summarise(total_trips = sum(trips))\n\n`summarise()` has grouped output by 'Mode'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 1 × 3\n# Groups:   Mode [1]\n  Mode            Agency                total_trips\n  &lt;chr&gt;           &lt;chr&gt;                       &lt;dbl&gt;\n1 Demand Response Altoona Metro Transit          26\n\n\n\nUSAGE_AND_FINANCIALS &lt;- USAGE_AND_FINANCIALS %&gt;% \n  mutate(Agent_Mode = str_c(`Agency Name`,Mode, sep = \", \")) #adding to main dataset\n\nUSAGE_AND_FINANCIALS %&gt;%\n    filter(Agent_Mode == 'Altoona Metro Transit, Demand Response') %&gt;% \n    select(Agent_Mode,`Total Fares`)\n\nAdding missing grouping variables: `Agency Name`, `Mode`\n\n\n# A tibble: 1 × 4\n# Groups:   Agency Name, Mode [1]\n  `Agency Name`         Mode            Agent_Mode                 `Total Fares`\n  &lt;chr&gt;                 &lt;chr&gt;           &lt;chr&gt;                              &lt;dbl&gt;\n1 Altoona Metro Transit Demand Response Altoona Metro Transit, De…         17163\n\n\nGiven that there is in fact 26 recorded trips with total fares of 17,163 there might be a chance that some info is missing, and if this is the case then the Alaskan Railroad would be the answer to this problem.\n\n\n\n\n ggplot(fare_per_trip,aes(x = Agent_Mode,y = fares_per_trip))+\n           geom_bar(stat = \"identity\",aes(fill= Agent_Mode),color= 'purple',show.legend = FALSE)+\n           theme_minimal()+\n           theme(axis.text.x = element_text(angle = 45,vjust =1,hjust = 1))+\n           labs(title = \"Fairs Per UPT(Unlinked Passenger Trips)\", x = \"Agency & Mode\",y = \"Fares Per Passenger Trips\")\n\n\n\n\n\n\n\n\n\n\n\nWe can use that new column along with arrange to get the lowest expense per VRM.\n\n         USAGE_AND_FINANCIALS %&gt;% \n           group_by(Agent_Mode) %&gt;% \n           mutate(expenses_per_vrm = Expenses/annual_vrm) %&gt;% \n           arrange(expenses_per_vrm) %&gt;% \n           select(Agent_Mode,expenses_per_vrm) %&gt;% \n           head(5)\n\n# A tibble: 5 × 2\n# Groups:   Agent_Mode [5]\n  Agent_Mode                                                expenses_per_vrm\n  &lt;chr&gt;                                                                &lt;dbl&gt;\n1 New Mexico Department of Transportation, Vanpool                     0.337\n2 VIA Metropolitan Transit, Vanpool                                    0.370\n3 County of Miami-Dade, Vanpool                                        0.386\n4 County of Volusia, Vanpool                                           0.393\n5 Corpus Christi Regional Transportation Authority, Vanpool            0.431\n\n\nUsing arrange(desc( ) ) gives us the ability to get the transit system with the highest expense per VRM.\n\n         USAGE_AND_FINANCIALS %&gt;% \n           group_by(Agent_Mode) %&gt;% \n           filter(annual_vrm != 0) %&gt;% # to avoid dividing by 0\n           mutate(expenses_per_vrm = Expenses/annual_vrm) %&gt;% \n           arrange(desc(expenses_per_vrm)) %&gt;% \n           select(Agent_Mode,expenses_per_vrm) %&gt;% \n           head(5)\n\n# A tibble: 5 × 2\n# Groups:   Agent_Mode [5]\n  Agent_Mode                                                    expenses_per_vrm\n  &lt;chr&gt;                                                                    &lt;dbl&gt;\n1 Altoona Metro Transit, Demand Response                                   1207.\n2 New York City Department of Transportation, Ferryboat                     771.\n3 New Orleans Regional Transit Authority, Ferryboat                         468.\n4 Loop Trolley Transportation Development District, Streetcar …             412.\n5 Washington State Ferries, Ferryboat                                       383.\n\n\nNotice there are several Ferryboats in this descending table. This indicates Ferries are more costly to operate then some of the other Modes like Vanpool, which does make sense.\n\n\n\n\n         fares_vrm&lt;-USAGE_AND_FINANCIALS %&gt;%\n           group_by(Agent_Mode) %&gt;% \n           filter(annual_vrm != 0) %&gt;% # to avoid dividing by 0\n           mutate(fares_per_vrm = `Total Fares`/annual_vrm) %&gt;%\n           arrange(desc(fares_per_vrm)) %&gt;% \n           select(Agent_Mode,fares_per_vrm) %&gt;% \n           head(10)\n         print(fares_vrm)\n\n# A tibble: 10 × 2\n# Groups:   Agent_Mode [10]\n   Agent_Mode                                                      fares_per_vrm\n   &lt;chr&gt;                                                                   &lt;dbl&gt;\n 1 Chicago Water Taxi (Wendella), Ferryboat                                237. \n 2 Altoona Metro Transit, Demand Response                                  229. \n 3 Jacksonville Transportation Authority, Ferryboat                        158. \n 4 Chattanooga Area Regional Transportation Authority, Inclined P…         149. \n 5 Hyannis Harbor Tours, Inc., Ferryboat                                   138. \n 6 SeaStreak, LLC, Ferryboat                                               115. \n 7 Bay State LLC, Ferryboat                                                110. \n 8 Cape May Lewes Ferry, Ferryboat                                          93.0\n 9 Woods Hole, Martha's Vineyard and Nantucket Steamship Authorit…          91.7\n10 Washington State Ferries, Ferryboat                                      78.1\n\n\nThis result shows many Ferryboat modes, which makes sense as ferry’s will be traveling shorter distances while charging the same or more than longer forms of transport.\n\n\n\n\n ggplot(fares_vrm,aes(x = Agent_Mode,y = fares_per_vrm))+\n           geom_bar(stat = \"identity\",aes(fill= Agent_Mode),color= 'lightblue',show.legend = FALSE)+\n           theme_bw()+\n           theme(axis.text.x = element_text(angle = 45,vjust =1,hjust = 1))+\n           labs(title = \"Fairs Per VRM(Vehicle Revenue Miles)\", x = \"Agency & Mode\",y = \"Fares Per VRM\")"
  },
  {
    "objectID": "mp01.html#intro",
    "href": "mp01.html#intro",
    "title": "Mini Project 1",
    "section": "",
    "text": "This analysis looks to provide some insights on the financial information behind some of the biggest transit agencies in the US. The data set being studied includes massive systems like the NYC Metro and also lesser used systems in states like Hawaii and Oklahoma."
  },
  {
    "objectID": "mp01.html#task-one-two-data-cleaning",
    "href": "mp01.html#task-one-two-data-cleaning",
    "title": "Mini Project 1",
    "section": "",
    "text": "After loading the data certain column names and row values need to be changed for syntactic reasons and ease of understanding. Firstly, changing the column UZA Name to metro_area will allow for syntactic ease, and a more intuitive label.\n\nUSAGE &lt;- inner_join(TRIPS, MILES) |&gt;\n    mutate(`NTD ID` = as.integer(`NTD ID`))\n\nJoining with `by = join_by(`NTD ID`, Agency, `UZA Name`, Mode, `3 Mode`,\nmonth)`\n\n    sample_n(USAGE, 1000) |&gt; \n    rename(\"metro_area\" = \"UZA Name\") %&gt;% #renaming UZA\n    mutate(month=as.character(month))\n\n# A tibble: 1,000 × 8\n   `NTD ID` Agency                 metro_area Mode  `3 Mode` month    UPT    VRM\n      &lt;int&gt; &lt;chr&gt;                  &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1    20113 Regional Transit Serv… Rochester… MB    Bus      2016… 1.33e6 417338\n 2    50019 City of Middletown     Middletow… DR    Bus      2008… 7.18e2   4172\n 3    30111 Washington County Tra… Pittsburg… MB    Bus      2014… 1.53e3   6581\n 4    20018 Central New York Regi… Syracuse,… DR    Bus      2019… 6.92e3 100968\n 5    60102 Concho Valley Transit… San Angel… MB    Bus      2008… 1.65e4  32176\n 6    50166 Clermont County, Ohio  Cincinnat… MB    Bus      2020… 7.2 e2   8974\n 7    50113 Pace, the Suburban Bu… Chicago, … VP    Bus      2011… 1.47e5 795247\n 8    40093 City of Greensboro     Greensbor… MB    Bus      2011… 3.34e5 164105\n 9    20004 Niagara Frontier Tran… Buffalo, … MB    Bus      2017… 1.73e6 665018\n10        7 Lane Transit District  Eugene, OR MB    Bus      2020… 1.15e3 124987\n# ℹ 990 more rows\n\n\nThe second section will be “re-coding” the Mode date in the dataframe. Since the data originally had codes like “HR” for Heavy Rail, or “FB” for Ferry Boat it will be hard for someone ignorant of these codes to understand the meaning behind them. So we will find all the distinct values, search their meanings, and then rename those values. The results will be displayed a Data Table using the DT library\n\n  distinct_modes&lt;- USAGE %&gt;% distinct(Mode)\n \n   USAGE &lt;- USAGE |&gt;\n     mutate(Mode=case_when(\n          Mode == \"HR\" ~ \"Heavy Rail\", \n          Mode == \"DR\"~\"Demand Response\",\n          Mode == \"FB\"~\"Ferryboat\",\n          Mode == \"MB\"~\"Bus\",\n          Mode == \"SR\"~\"Streetcar Rail\",\n          Mode == \"TB\"~\"Trolleybus\",\n          Mode == \"VP\"~\"Vanpool\",\n          Mode == \"CB\"~\"Commuter Bus\",\n          Mode == \"RB\"~\"Bus Rapid Transit\",\n          Mode == \"LR\"~\"Light Rail\",\n          Mode == \"YR\"~\"Hybrid Rail\",\n          Mode == \"MG\"~\"Monorail Automated Guideway\",\n          Mode == \"CR\"~\"Commuter Rail\",\n          Mode == \"AR\"~\"Alaska Railroad\",\n          Mode == \"TR\"~\"Aerial Tramway\",\n          Mode == \"IP\"~\"Inclined Plane\",\n          Mode == \"PB\"~\"Publico\",\n          Mode == \"CC\"~\"Cable Car\",\n          TRUE~\"Unknown\"))\n    Use_table &lt;- DT::datatable(head(USAGE, 5000))"
  },
  {
    "objectID": "mp01.html#task-3-answering-questions-using-dyplr",
    "href": "mp01.html#task-3-answering-questions-using-dyplr",
    "title": "Mini Project 1",
    "section": "",
    "text": "Using the arrange function we can sort the data based on a ascending or descending order of a specified value. Using arrange combined with desc function we get the all the VRM values starting from highest to lowest. The corresponding agency will be the answer.\n\nMax_VRM &lt;- USAGE %&gt;% \n    select(VRM,Agency) %&gt;%\n    arrange(desc(VRM)) %&gt;% \n    head(1)\n    print(Max_VRM)\n\n# A tibble: 1 × 2\n       VRM Agency                   \n     &lt;dbl&gt; &lt;chr&gt;                    \n1 30882144 MTA New York City Transit\n\n\n\n\n\nUsing the same idea as the previous question, this time combining it with the group_by function will allow us to find the answer. The group_by function creates “groups” of a given variable to then perform some action to those groups. In this case we will group by the mode and then sum up the VRM for each mode. This method will provide the answer “Bus”\n\nvrm_by_mode &lt;- USAGE %&gt;% \n    select(VRM,Mode) %&gt;%\n    group_by(Mode) %&gt;% \n    summarise(Total = sum(VRM)) %&gt;% \n    arrange(desc(Total))\n    print(vrm_by_mode)\n\n# A tibble: 18 × 2\n   Mode                              Total\n   &lt;chr&gt;                             &lt;dbl&gt;\n 1 Bus                         49444494088\n 2 Demand Response             17955073508\n 3 Heavy Rail                  14620362107\n 4 Commuter Rail                6970644241\n 5 Vanpool                      3015783362\n 6 Light Rail                   2090094714\n 7 Commuter Bus                 1380948975\n 8 Publico                      1021270808\n 9 Trolleybus                    236840288\n10 Bus Rapid Transit             118425283\n11 Ferryboat                      65589783\n12 Streetcar Rail                 63389725\n13 Monorail Automated Guideway    37879729\n14 Hybrid Rail                    37787608\n15 Alaska Railroad                13833261\n16 Cable Car                       7386019\n17 Inclined Plane                   705904\n18 Aerial Tramway                   292860\n\n\n\n\n\nTo answer this the use of the filter function is required. The filter function will remove all the data that doesn’t agree with the filter statement, allowing for more specific analysis. Filtering for a May 2024 date and a NYC MTA Agency Subway will give the answer, but first some data manipulating is required. Creating a year and month column with the lubridate library, allows for quick and easy date time analysis and will come in handy, making future analysis streamlined. After doing so the previous techniques are used.\n\n  typeof(USAGE$month)#checking the type of column month is\n\n[1] \"double\"\n\nlibrary(lubridate)\n  USAGE$month &lt;- ymd(USAGE$month) #changing to date format\n  USAGE &lt;- USAGE %&gt;% \n     rename(\"trips\"=UPT) %&gt;% #renaming the UPT(Unlinked passenger trips)- to trips\n     rename(\"date\"=month) %&gt;%  \n     mutate(\"year\"= year(date)) %&gt;%\n     mutate('month'= month(date))\n  nyc_trips &lt;- USAGE %&gt;% \n    filter(Agency == \"MTA New York City Transit\" & Mode ==\"Heavy Rail\")%&gt;% \n    filter(year==2024 & month == 5) %&gt;% \n    summarise(may_total=sum(trips))\n    print(nyc_trips)\n\n# A tibble: 1 × 1\n  may_total\n      &lt;dbl&gt;\n1 180458819\n\n\n\n\n\nUsing all the techniques from the previous questions, along with the pull method to give a singular value will provide an answer for this question. After pulling the data for both cases we can simply find the difference.\n\n  nyc_monthly &lt;- USAGE %&gt;% #this table provides info that might be useful later on\n    filter(Agency == 'MTA New York City Transit' & Mode == 'Heavy Rail') %&gt;% \n    group_by(year, month) %&gt;%                       \n    mutate(total_vrm = sum(VRM)) %&gt;% \n    mutate(total_trips = sum(trips)) %&gt;%\n    select(year,month,total_trips,total_vrm)\n   vrm_2019 &lt;- nyc_monthly %&gt;%\n    filter(year == 2019 & month == 4) %&gt;% \n    pull(total_vrm)\n  \n  vrm_2020 &lt;- nyc_monthly %&gt;%\n    filter(year == 2020 & month == 4) %&gt;% \n    pull(total_vrm)\n  \n  print(\"VRM Difference\")\n\n[1] \"VRM Difference\"\n\n  vrm_2019-vrm_2020 #difference in Vehicle Revenue Miles\n\n[1] 12200677\n\n  trips_2019 &lt;- nyc_monthly %&gt;%\n    filter(year == 2019 & month == 4) %&gt;% \n    pull(total_trips)\n  \n  trips_2020 &lt;- nyc_monthly %&gt;%\n    filter(year == 2020 & month == 4) %&gt;% \n    pull(total_trips)\n  print(\"Trips Difference\")\n\n[1] \"Trips Difference\"\n\n  trips_2019-trips_2020 #decrease in trips\n\n[1] 211969660\n\n\n\n\n\n\n\nUsing a combintion of techniques like filtering, summarize, as well as grouping by the month column will provide the answer.\n\n     USAGE %&gt;% \n     filter(year == 2023) %&gt;% \n     select(year,month,VRM) %&gt;% \n     group_by(month) %&gt;% \n     summarise(total_vrm = sum(VRM)) %&gt;% \n     arrange(desc(total_vrm))\n\n# A tibble: 12 × 2\n   month total_vrm\n   &lt;dbl&gt;     &lt;dbl&gt;\n 1     8 422002435\n 2    10 420684229\n 3     3 413311032\n 4     5 407605645\n 5    11 402542477\n 6     6 400875583\n 7    12 399428041\n 8     7 398685473\n 9     9 398172153\n10     1 389141732\n11     4 386876164\n12     2 361882307\n\n\n\n\n\nSimilarly with this question grouping by year and computing the desired value, using mutate this time, gives us the answer. We can also plot this to see some yearly trends using ggplot.\n\n  yearly_trips &lt;- USAGE %&gt;% \n     group_by(year) %&gt;% \n     mutate(total_trips = sum(trips)) %&gt;%\n     mutate(avg_trip_day = total_trips/365) %&gt;% \n     select(year,total_trips,avg_trip_day) %&gt;% \n     arrange(desc(total_trips)) %&gt;% \n     distinct(year,total_trips,avg_trip_day)\n     #plotting\n     ggplot(yearly_trips,aes(x= year,y=avg_trip_day))+\n       geom_line(color = 'blue')+\n       labs(title = \"Trends in Avg Trips Per Day\", y = \"Unlinked Trips\",x = \"Years\")+\n       theme_minimal()\n\n\n\n\n\n\n\n\nPredictably, there is a huge drop in 2020 in average trips.\n\n\n\nTo answer this we can group by metro area and then summarize for the mean of area. After generating a dataframe with these values we can see Chicago was the highest followed by Las Vegas area, and the lowest was Cheyenne,WY. We can also create a bar graph of the top 10 areas to visualize this clearly. Using the aes (aesthetic) function with fill = metro_area allows for a colorful representation of each chart. This method creates a legend we don’t need so we set show.legend = FALSE. The element text function allows for the X label to be angled and positioned correctly for long label names.\n\n   USAGE &lt;- USAGE %&gt;% rename(\"metro_area\" = \"UZA Name\")#had to rerun this code\n \n   trips_by_area &lt;- USAGE %&gt;% \n        select(year,metro_area,trips) %&gt;% \n        group_by(metro_area) %&gt;% \n        summarise(avg_trips = mean(trips)) %&gt;% \n        arrange(desc(avg_trips)) %&gt;% \n        head(10)\n\n    ggplot(trips_by_area,aes(x = metro_area,y = avg_trips))+\n        geom_bar(stat = 'identity',aes(fill = metro_area),color = \"red\",show.legend = FALSE)+\n        theme_minimal()+\n        theme(axis.text.x = element_text(angle = 45, hjust = 1,vjust = 1))+\n        labs(title = \"Average Trips by City\",y= \"Unlinked Passenger Trips\", x= \"Metro Area\")\n\n\n\n\n\n\n\n\n\n\n\n\nThis task pertains to joining two tables to create a Usage and financial table. We will join on the keys NTD ID and Mode. Since the mode is different in the financial table (recall it was altered for usability) it must also be changed. Grouping by NTD ID and Mode allows for us answer the questions in Task 6 which requires transportation agency and method to be combined, since each agency has its own unique ID this is exactly the same thing.\n\n  USAGE_2022_ANNUAL &lt;- USAGE %&gt;% \n        filter(year == 2022) %&gt;% \n        select('NTD ID',Mode,Agency,metro_area,trips,VRM) %&gt;% \n        group_by(`NTD ID`,Mode) %&gt;% \n        summarise(annual_trips = sum(trips),annual_vrm = sum(VRM)) %&gt;% \n        ungroup()\n\n`summarise()` has grouped output by 'NTD ID'. You can override using the\n`.groups` argument.\n\n      Financials &lt;- Financials |&gt;\n     mutate(Mode=case_when(\n          Mode == \"HR\" ~ \"Heavy Rail\", \n          Mode == \"DR\"~\"Demand Response\",\n          Mode == \"FB\"~\"Ferryboat\",\n          Mode == \"MB\"~\"Bus\",\n          Mode == \"SR\"~\"Streetcar Rail\",\n          Mode == \"TB\"~\"Trolleybus\",\n          Mode == \"VP\"~\"Vanpool\",\n          Mode == \"CB\"~\"Commuter Bus\",\n          Mode == \"RB\"~\"Bus Rapid Transit\",\n          Mode == \"LR\"~\"Light Rail\",\n          Mode == \"YR\"~\"Hybrid Rail\",\n          Mode == \"MG\"~\"Monorail Automated Guideway\",\n          Mode == \"CR\"~\"Commuter Rail\",\n          Mode == \"AR\"~\"Alaska Railroad\",\n          Mode == \"TR\"~\"Aerial Tramway\",\n          Mode == \"IP\"~\"Inclined Plane\",\n          Mode == \"PB\"~\"Publico\",\n          Mode == \"CC\"~\"Cable Car\",\n          TRUE~\"Unknown\"))\n      \n      USAGE_AND_FINANCIALS &lt;- left_join(USAGE_2022_ANNUAL, \n           Financials, \n           join_by(`NTD ID`, Mode)) |&gt;\n           drop_na()\n\n\n\n\n\n\nUsing Group_by and summarize with max( ) we get the answer New York MTA and Heavy Rail.\n\n      USAGE_AND_FINANCIALS %&gt;% \n        group_by(`Agency Name`,`Mode`) %&gt;% \n        summarise(max_trips = max(annual_trips)) %&gt;% \n        arrange(desc(max_trips)) %&gt;% \n        head(1)\n\n# A tibble: 1 × 3\n# Groups:   Agency Name [1]\n  `Agency Name`             Mode        max_trips\n  &lt;chr&gt;                     &lt;chr&gt;           &lt;dbl&gt;\n1 MTA New York City Transit Heavy Rail 1793073801\n\n\n\n\n\nUsing mutate to create another calculated column with the Fare Box Ratio formula we get the answer, Vanpool in the Central Kentucky agency. This makes sense as vanpool is essentially car pooling in small vehicles like vans and small buses for shorter distances. This allows for lower costs then other modes like for example Heavy Rail, which require lots of maintenance and overhead.\n\n      USAGE_AND_FINANCIALS&lt;-USAGE_AND_FINANCIALS %&gt;% \n         group_by(`Agency Name`,`Mode`) %&gt;% \n         mutate(fare_box_recovery = `Total Fares`/Expenses) %&gt;%\n         arrange(desc(fare_box_recovery))\n         print(USAGE_AND_FINANCIALS)\n\n# A tibble: 1,132 × 8\n# Groups:   Agency Name, Mode [1,130]\n   `NTD ID` Mode    annual_trips annual_vrm `Agency Name` `Total Fares` Expenses\n      &lt;dbl&gt; &lt;chr&gt;          &lt;dbl&gt;      &lt;dbl&gt; &lt;chr&gt;                 &lt;dbl&gt;    &lt;dbl&gt;\n 1    40191 Vanpool         9640      94027 Transit Auth…         97300    40801\n 2    40034 Vanpool       395004    3091052 County of Mi…       1987879  1191874\n 3    90233 Vanpool        70093     462346 Yuma County …        411216   279585\n 4    20190 Ferryb…      3757873     504037 Port Imperia…      33443241 23417248\n 5    11239 Ferryb…       878728     188694 Hyannis Harb…      25972659 18383764\n 6    11238 Ferryb…        96707      56980 Bay State LLC       6287351  4672351\n 7    20169 Commut…       403646    1259602 Trans-Bridge…      11325199  8495611\n 8    40001 Inclin…       481957      20128 Chattanooga …       3005198  2290714\n 9    66339 Vanpool       118780    1748901 New Mexico D…        757574   588830\n10       12 Vanpool       189684    1582484 Municipality…       1400709  1105911\n# ℹ 1,122 more rows\n# ℹ 1 more variable: fare_box_recovery &lt;dbl&gt;\n\n\n\n\n\nSimilarly we can answer this question.\n\n       USAGE_AND_FINANCIALS %&gt;% \n           group_by(`Agency Name`,`Mode`) %&gt;% \n           mutate(expenses_per_trip = Expenses/annual_trips) %&gt;% \n           select(`Agency Name`,Mode,expenses_per_trip) %&gt;% \n           arrange(expenses_per_trip)\n\n# A tibble: 1,132 × 3\n# Groups:   Agency Name, Mode [1,130]\n   `Agency Name`                                         Mode  expenses_per_trip\n   &lt;chr&gt;                                                 &lt;chr&gt;             &lt;dbl&gt;\n 1 North Carolina State University                       Bus                1.18\n 2 Anaheim Transportation Network                        Bus                1.28\n 3 Valley Metro Rail, Inc.                               Stre…              1.49\n 4 University of Iowa                                    Bus                1.54\n 5 Chatham Area Transit Authority                        Ferr…              1.60\n 6 Texas State University                                Bus                2.05\n 7 South Florida Regional Transportation Authority       Bus                2.27\n 8 University of Georgia                                 Bus                2.31\n 9 Hillsborough Area Regional Transit Authority          Stre…              2.45\n10 University of Michigan Parking and Transportation Se… Bus                2.52\n# ℹ 1,122 more rows\n\n\nIndicates that buses have a low cost per person.\n\n\n\nIn this question, an extra step will be taken for later use to both easily answer more questions and also effectively produce some visualizations based on the given problems. Firstly, using mutate to calculate Fares/ UPT(Trips) grouped by the agency and mode will be enough to answer the question. The second additional step will be to make a new column that contains both the agency and the mode in one column. This will make it easier to get this information, and also will allow use to graph these grouped problems. To do this the use of the stringr library. This library is used for manipulating strings, and in this case it will be used to combine the 2 strings in both agent and mode columns.\n\nlibrary(stringr)\n       fare_per_trip &lt;- USAGE_AND_FINANCIALS %&gt;% \n           group_by(`Agency Name`,`Mode`) %&gt;% \n           mutate(fares_per_trip = `Total Fares`/annual_trips) %&gt;% \n           mutate(Agent_Mode = str_c(`Agency Name`,Mode, sep = \", \")) %&gt;% #joining the col strings with a comma and space\n           arrange(desc(fares_per_trip)) %&gt;% \n           select(`Agency Name`,fares_per_trip,Mode,Agent_Mode) %&gt;%\n           head(10)\n       print(fare_per_trip)\n\n# A tibble: 10 × 4\n# Groups:   Agency Name, Mode [10]\n   `Agency Name`                                 fares_per_trip Mode  Agent_Mode\n   &lt;chr&gt;                                                  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     \n 1 Altoona Metro Transit                                  660.  Dema… Altoona M…\n 2 Alaska Railroad Corporation                            153.  Alas… Alaska Ra…\n 3 Bay State LLC                                           65.0 Ferr… Bay State…\n 4 Central Pennsylvania Transportation Authority           50.2 Dema… Central P…\n 5 Hampton Jitney, Inc.                                    41.3 Comm… Hampton J…\n 6 County of Placer                                        38.8 Comm… County of…\n 7 Audubon Area Community Services, Inc.                   37.4 Dema… Audubon A…\n 8 Lane Transit District                                   34.0 Dema… Lane Tran…\n 9 Pennsylvania Department of Transportation               32.3 Comm… Pennsylva…\n10 Hyannis Harbor Tours, Inc.                              29.6 Ferr… Hyannis H…\n\n\nWith the new column, removing agent and mode columns.\n\n  fare_per_trip %&gt;% \n     ungroup() %&gt;% \n     select(Agent_Mode,fares_per_trip)\n\n# A tibble: 10 × 2\n   Agent_Mode                                                     fares_per_trip\n   &lt;chr&gt;                                                                   &lt;dbl&gt;\n 1 Altoona Metro Transit, Demand Response                                  660. \n 2 Alaska Railroad Corporation, Alaska Railroad                            153. \n 3 Bay State LLC, Ferryboat                                                 65.0\n 4 Central Pennsylvania Transportation Authority, Demand Response           50.2\n 5 Hampton Jitney, Inc., Commuter Bus                                       41.3\n 6 County of Placer, Commuter Bus                                           38.8\n 7 Audubon Area Community Services, Inc., Demand Response                   37.4\n 8 Lane Transit District, Demand Response                                   34.0\n 9 Pennsylvania Department of Transportation, Commuter Rail                 32.3\n10 Hyannis Harbor Tours, Inc., Ferryboat                                    29.6\n\n\nAs you can see it is very simple to read\nSince the Altoona per trip price is so high, some additional analysis is required.\n\n  USAGE %&gt;%\n    group_by(Mode,Agency) %&gt;% \n    filter(Agency == 'Altoona Metro Transit'& year == 2022) %&gt;% \n    filter(Mode== \"Demand Response\") %&gt;%\n    summarise(total_trips = sum(trips))\n\n`summarise()` has grouped output by 'Mode'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 1 × 3\n# Groups:   Mode [1]\n  Mode            Agency                total_trips\n  &lt;chr&gt;           &lt;chr&gt;                       &lt;dbl&gt;\n1 Demand Response Altoona Metro Transit          26\n\n\n\nUSAGE_AND_FINANCIALS &lt;- USAGE_AND_FINANCIALS %&gt;% \n  mutate(Agent_Mode = str_c(`Agency Name`,Mode, sep = \", \")) #adding to main dataset\n\nUSAGE_AND_FINANCIALS %&gt;%\n    filter(Agent_Mode == 'Altoona Metro Transit, Demand Response') %&gt;% \n    select(Agent_Mode,`Total Fares`)\n\nAdding missing grouping variables: `Agency Name`, `Mode`\n\n\n# A tibble: 1 × 4\n# Groups:   Agency Name, Mode [1]\n  `Agency Name`         Mode            Agent_Mode                 `Total Fares`\n  &lt;chr&gt;                 &lt;chr&gt;           &lt;chr&gt;                              &lt;dbl&gt;\n1 Altoona Metro Transit Demand Response Altoona Metro Transit, De…         17163\n\n\nGiven that there is in fact 26 recorded trips with total fares of 17,163 there might be a chance that some info is missing, and if this is the case then the Alaskan Railroad would be the answer to this problem.\n\n\n\n\n ggplot(fare_per_trip,aes(x = Agent_Mode,y = fares_per_trip))+\n           geom_bar(stat = \"identity\",aes(fill= Agent_Mode),color= 'purple',show.legend = FALSE)+\n           theme_minimal()+\n           theme(axis.text.x = element_text(angle = 45,vjust =1,hjust = 1))+\n           labs(title = \"Fairs Per UPT(Unlinked Passenger Trips)\", x = \"Agency & Mode\",y = \"Fares Per Passenger Trips\")\n\n\n\n\n\n\n\n\n\n\n\nWe can use that new column along with arrange to get the lowest expense per VRM.\n\n         USAGE_AND_FINANCIALS %&gt;% \n           group_by(Agent_Mode) %&gt;% \n           mutate(expenses_per_vrm = Expenses/annual_vrm) %&gt;% \n           arrange(expenses_per_vrm) %&gt;% \n           select(Agent_Mode,expenses_per_vrm) %&gt;% \n           head(5)\n\n# A tibble: 5 × 2\n# Groups:   Agent_Mode [5]\n  Agent_Mode                                                expenses_per_vrm\n  &lt;chr&gt;                                                                &lt;dbl&gt;\n1 New Mexico Department of Transportation, Vanpool                     0.337\n2 VIA Metropolitan Transit, Vanpool                                    0.370\n3 County of Miami-Dade, Vanpool                                        0.386\n4 County of Volusia, Vanpool                                           0.393\n5 Corpus Christi Regional Transportation Authority, Vanpool            0.431\n\n\nUsing arrange(desc( ) ) gives us the ability to get the transit system with the highest expense per VRM.\n\n         USAGE_AND_FINANCIALS %&gt;% \n           group_by(Agent_Mode) %&gt;% \n           filter(annual_vrm != 0) %&gt;% # to avoid dividing by 0\n           mutate(expenses_per_vrm = Expenses/annual_vrm) %&gt;% \n           arrange(desc(expenses_per_vrm)) %&gt;% \n           select(Agent_Mode,expenses_per_vrm) %&gt;% \n           head(5)\n\n# A tibble: 5 × 2\n# Groups:   Agent_Mode [5]\n  Agent_Mode                                                    expenses_per_vrm\n  &lt;chr&gt;                                                                    &lt;dbl&gt;\n1 Altoona Metro Transit, Demand Response                                   1207.\n2 New York City Department of Transportation, Ferryboat                     771.\n3 New Orleans Regional Transit Authority, Ferryboat                         468.\n4 Loop Trolley Transportation Development District, Streetcar …             412.\n5 Washington State Ferries, Ferryboat                                       383.\n\n\nNotice there are several Ferryboats in this descending table. This indicates Ferries are more costly to operate then some of the other Modes like Vanpool, which does make sense.\n\n\n\n\n         fares_vrm&lt;-USAGE_AND_FINANCIALS %&gt;%\n           group_by(Agent_Mode) %&gt;% \n           filter(annual_vrm != 0) %&gt;% # to avoid dividing by 0\n           mutate(fares_per_vrm = `Total Fares`/annual_vrm) %&gt;%\n           arrange(desc(fares_per_vrm)) %&gt;% \n           select(Agent_Mode,fares_per_vrm) %&gt;% \n           head(10)\n         print(fares_vrm)\n\n# A tibble: 10 × 2\n# Groups:   Agent_Mode [10]\n   Agent_Mode                                                      fares_per_vrm\n   &lt;chr&gt;                                                                   &lt;dbl&gt;\n 1 Chicago Water Taxi (Wendella), Ferryboat                                237. \n 2 Altoona Metro Transit, Demand Response                                  229. \n 3 Jacksonville Transportation Authority, Ferryboat                        158. \n 4 Chattanooga Area Regional Transportation Authority, Inclined P…         149. \n 5 Hyannis Harbor Tours, Inc., Ferryboat                                   138. \n 6 SeaStreak, LLC, Ferryboat                                               115. \n 7 Bay State LLC, Ferryboat                                                110. \n 8 Cape May Lewes Ferry, Ferryboat                                          93.0\n 9 Woods Hole, Martha's Vineyard and Nantucket Steamship Authorit…          91.7\n10 Washington State Ferries, Ferryboat                                      78.1\n\n\nThis result shows many Ferryboat modes, which makes sense as ferry’s will be traveling shorter distances while charging the same or more than longer forms of transport.\n\n\n\n\n ggplot(fares_vrm,aes(x = Agent_Mode,y = fares_per_vrm))+\n           geom_bar(stat = \"identity\",aes(fill= Agent_Mode),color= 'lightblue',show.legend = FALSE)+\n           theme_bw()+\n           theme(axis.text.x = element_text(angle = 45,vjust =1,hjust = 1))+\n           labs(title = \"Fairs Per VRM(Vehicle Revenue Miles)\", x = \"Agency & Mode\",y = \"Fares Per VRM\")"
  },
  {
    "objectID": "MP02.html",
    "href": "MP02.html",
    "title": "Mini Project#2 - Hollywood Analysis",
    "section": "",
    "text": "fkd aafnlfnDN\n\n\nSince the data is very large we will need to reduce the size of the data by filtering out the information that is not useful for analysis. We can do this by removing people with less than 2 “known for” title credits and also removing rare movies with less than 100 ratings.\n\n\nShow the code\nlibrary(ggplot2)\nTITLE_RATINGS |&gt;\n    ggplot(aes(x=numVotes)) + \n    geom_histogram(bins=30) +\n    xlab(\"Number of IMDB Ratings\") + \n    ylab(\"Number of Titles\") + \n    ggtitle(\"Majority of IMDB Titles Have Less than 100 Ratings\") + \n    theme_bw() + \n    scale_x_log10(label=scales::comma) + \n    scale_y_continuous(label=scales::comma)\n\n\n\n\n\n\n\n\n\nThe graph above is a great representation of the distribution of the our movie data with number of ratings as a descriptor. Showcases how a significant chunk of our date has a number of ratings that is less than 100.\n\n\n\n\n\nShow the code\nlibrary(stringr)\nlibrary(dplyr)\nNAME_BASICS &lt;- NAME_BASICS |&gt; \n  filter(str_count(knownForTitles, \",\") &gt; 1) #filtering the known for titles\n#removing those titles that have less than 100 ratings\n\nTITLE_RATINGS &lt;- TITLE_RATINGS |&gt;\n    filter(numVotes &gt;= 100)\n# now using this to reduced date to filter all the other tables with semi_join \nTITLE_BASICS &lt;- TITLE_BASICS |&gt;\n    semi_join(TITLE_RATINGS, \n              join_by(tconst == tconst))\n\nTITLE_CREW &lt;- TITLE_CREW |&gt;\n    semi_join(TITLE_RATINGS, \n              join_by(tconst == tconst))\n\nTITLE_EPISODES_1 &lt;- TITLE_EPISODES |&gt;\n    semi_join(TITLE_RATINGS, \n              join_by(tconst == tconst))\nTITLE_EPISODES_2 &lt;- TITLE_EPISODES |&gt;\n    semi_join(TITLE_RATINGS, \n              join_by(parentTconst == tconst))\n\nTITLE_EPISODES &lt;- bind_rows(TITLE_EPISODES_1,\n                            TITLE_EPISODES_2) |&gt;\n    distinct()\n\nTITLE_PRINCIPALS &lt;- TITLE_PRINCIPALS |&gt;\n    semi_join(TITLE_RATINGS, join_by(tconst == tconst))\n\nrm(TITLE_EPISODES_1)\nrm(TITLE_EPISODES_2)\n\n\nThe code above uses a semi-join to filter the other tables, ensuring that they only retain rows with keys that match those in the initial table without actually joining any tables together.\n\n\n\nMost of the time, data will contain many discrepancies. In the case of this data the source used the character \\\\N to representing a missing value within numeric columns. This raises two problems, firstly R does not recognize \\\\N as null, and the columns that should be numeric are in the string format. We can fix both by using as.numeric , which will convert the columns into numeric and also turn unrecognized strings into NAs.\n\n\nShow the code\n### Cleaning the data ####\nglimpse(TITLE_BASICS)\n\n\nRows: 374,145\nColumns: 9\n$ tconst         &lt;chr&gt; \"tt0000001\", \"tt0000002\", \"tt0000003\", \"tt0000004\", \"tt…\n$ titleType      &lt;chr&gt; \"short\", \"short\", \"short\", \"short\", \"short\", \"short\", \"…\n$ primaryTitle   &lt;chr&gt; \"Carmencita\", \"Le clown et ses chiens\", \"Poor Pierrot\",…\n$ originalTitle  &lt;chr&gt; \"Carmencita\", \"Le clown et ses chiens\", \"Pauvre Pierrot…\n$ isAdult        &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ startYear      &lt;chr&gt; \"1894\", \"1892\", \"1892\", \"1892\", \"1893\", \"1894\", \"1894\",…\n$ endYear        &lt;chr&gt; \"\\\\N\", \"\\\\N\", \"\\\\N\", \"\\\\N\", \"\\\\N\", \"\\\\N\", \"\\\\N\", \"\\\\N\",…\n$ runtimeMinutes &lt;chr&gt; \"1\", \"5\", \"5\", \"12\", \"1\", \"1\", \"1\", \"1\", \"45\", \"1\", \"1\"…\n$ genres         &lt;chr&gt; \"Documentary,Short\", \"Animation,Short\", \"Animation,Come…\n\n\nShow the code\nprint(\"________________\")\n\n\n[1] \"________________\"\n\n\nShow the code\nglimpse(TITLE_EPISODES)\n\n\nRows: 3,022,865\nColumns: 4\n$ tconst        &lt;chr&gt; \"tt0045960\", \"tt0046855\", \"tt0048378\", \"tt0048562\", \"tt0…\n$ parentTconst  &lt;chr&gt; \"tt0044284\", \"tt0046643\", \"tt0047702\", \"tt0047768\", \"tt0…\n$ seasonNumber  &lt;chr&gt; \"2\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"3\", \"3\", \"…\n$ episodeNumber &lt;chr&gt; \"3\", \"4\", \"6\", \"10\", \"4\", \"20\", \"5\", \"2\", \"20\", \"6\", \"2\"…\n\n\nShow the code\nNAME_BASICS &lt;- NAME_BASICS |&gt;\n    mutate(birthYear = as.numeric(birthYear),\n           deathYear = as.numeric(deathYear)) # using the as numeric to force non-numeric into actual N/A instead of the \\\\N.R provides by the data\n\n\nWarning: There were 2 warnings in `mutate()`.\nThe first warning was:\nℹ In argument: `birthYear = as.numeric(birthYear)`.\nCaused by warning:\n! NAs introduced by coercion\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\n\nShow the code\nTITLE_BASICS &lt;- TITLE_BASICS |&gt;\n    mutate(startYear = as.numeric(startYear),\n           endYear = as.numeric(endYear),\n           isAdult = as.logical(isAdult))\n\n\nWarning: There were 2 warnings in `mutate()`.\nThe first warning was:\nℹ In argument: `startYear = as.numeric(startYear)`.\nCaused by warning:\n! NAs introduced by coercion\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\n\nShow the code\nTITLE_EPISODES &lt;- TITLE_EPISODES |&gt;\n    mutate(seasonNumber = as.numeric(seasonNumber),\n           episodeNumber = as.numeric(episodeNumber))\n\n\nWarning: There were 2 warnings in `mutate()`.\nThe first warning was:\nℹ In argument: `seasonNumber = as.numeric(seasonNumber)`.\nCaused by warning:\n! NAs introduced by coercion\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\n\nOur data also contains rows that have multiple values per cell. Separating these into their own rows will allow us to do a more detailed analysis later on. The code below does exactly that.\n\n\nShow the code\nNAME_BASICS |&gt; separate_longer_delim(knownForTitles, \",\") |&gt; slice_head(n=10)\n\n\n      nconst     primaryName birthYear deathYear\n1  nm0000001    Fred Astaire      1899      1987\n2  nm0000001    Fred Astaire      1899      1987\n3  nm0000001    Fred Astaire      1899      1987\n4  nm0000001    Fred Astaire      1899      1987\n5  nm0000002   Lauren Bacall      1924      2014\n6  nm0000002   Lauren Bacall      1924      2014\n7  nm0000002   Lauren Bacall      1924      2014\n8  nm0000002   Lauren Bacall      1924      2014\n9  nm0000003 Brigitte Bardot      1934        NA\n10 nm0000003 Brigitte Bardot      1934        NA\n                    primaryProfession knownForTitles\n1        actor,miscellaneous,producer      tt0050419\n2        actor,miscellaneous,producer      tt0072308\n3        actor,miscellaneous,producer      tt0053137\n4        actor,miscellaneous,producer      tt0027125\n5  actress,soundtrack,archive_footage      tt0037382\n6  actress,soundtrack,archive_footage      tt0075213\n7  actress,soundtrack,archive_footage      tt0117057\n8  actress,soundtrack,archive_footage      tt0038355\n9   actress,music_department,producer      tt0057345\n10  actress,music_department,producer      tt0049189\n\n\n\n\n\n\n\nTo answer this question we can first find out which table provides the answer efficiently. Looking at the tables, TITLE_BASICS seems to contain the most relevant information. By first using the Unique function on the title type column, we can see how best to filter our data to count each category.\n\n\nShow the code\n  unique(TITLE_BASICS$titleType)\n\n\n [1] \"short\"        \"movie\"        \"tvSeries\"     \"tvShort\"      \"tvMovie\"     \n [6] \"tvEpisode\"    \"tvMiniSeries\" \"video\"        \"tvSpecial\"    \"videoGame\"   \n\n\nThis shows us all the categories in the column and how to properly query them without scrolling through hundreds of rows of data. This shows some interesting information like the video game category which you wouldn’t expect to see on a film database\n\n\nShow the code\ncat(\"Number of Movies in Data:\",  TITLE_BASICS %&gt;% filter(titleType == \"movie\") %&gt;% summarise(count = n()) %&gt;% pull(count),\"\\n\") \n\n\nNumber of Movies in Data: 132220 \n\n\nShow the code\ncat(\"Number of TV Series:\", TITLE_BASICS %&gt;% filter(titleType == \"tvSeries\") %&gt;% summarise(count = n()) %&gt;% pull(count),\"\\n\")\n\n\nNumber of TV Series: 29986 \n\n\nShow the code\ncat(\"Number of TV episodes:\", TITLE_BASICS %&gt;% filter(titleType == \"tvEpisode\") %&gt;% summarise(count = n()) %&gt;% pull(count))\n\n\nNumber of TV episodes: 156725\n\n\n\n\n\nIn order to get an accurate answer, and basing it mostly on the data at hand we must use the filter function for living people and getting the minimum birth year that makes sense. This assumes that the death date is in fact accurate and is a death date. Something to note is that at least one group of people is listed in this table, under the name Cherry Bullet with a death date of 2024. This data point is misleading as this is not a single person but a KPOP group, and the death date is the date the band separated.\n\n\nShow the code\nNAME_BASICS %&gt;% filter(is.na(deathYear),!is.na(birthYear), 2024-birthYear &lt;= 100) %&gt;% arrange(birthYear) %&gt;% head(10)\n\n\n      nconst              primaryName birthYear deathYear\n1  nm0001693          Eva Marie Saint      1924        NA\n2  nm0011140                Lee Adams      1924        NA\n3  nm0021786         Humberto Almazán      1924        NA\n4  nm0073561        Yuriy Berenshteyn      1924        NA\n5  nm0080310 Harsukh Jagneshwar Bhatt      1924        NA\n6  nm0084762          Bo Bjelfvenstam      1924        NA\n7  nm0097155            Carola Bornée      1924        NA\n8  nm0106849            Pietro Bregni      1924        NA\n9  nm0121557             Michael Burk      1924        NA\n10 nm0130807          Hillevi Calvert      1924        NA\n                      primaryProfession\n1           actress,producer,soundtrack\n2  music_department,actor,miscellaneous\n3                                 actor\n4                       cinematographer\n5  director,assistant_director,producer\n6              director,writer,producer\n7                              producer\n8                              producer\n9                 actor,writer,director\n10                    script_department\n                               knownForTitles\n1     tt0047296,tt0053125,tt0348150,tt1837709\n2     tt0423977,tt0112605,tt6294822,tt0131369\n3     tt0050144,tt0249863,tt0223581,tt0244475\n4               tt0057509,tt8157292,tt9066040\n5     tt0156724,tt0156556,tt0156995,tt0156718\n6  tt26241720,tt32591822,tt14358988,tt7075484\n7    tt4493588,tt0051094,tt10250868,tt0048404\n8     tt0141673,tt0094787,tt0101493,tt0075845\n9     tt0312036,tt0054327,tt0048565,tt0048402\n10    tt0039315,tt0038385,tt0036884,tt0037544\n\n\nThis code finds all the people with missing death dates and also filters for and age max of 100. Any list of data with a calculated age more than this not only starts to become unreasonable but also fails to be true after a quick Google search. Using this method we get Eva Marie Saint.\n\n\n\n\nTo answer this we will need to do a couple of join statements.\n\n\nShow the code\nseries_name &lt;- TITLE_EPISODES %&gt;% #allows us to get the name of show,not just episode\n  inner_join(TITLE_BASICS, by = c('parentTconst' = 'tconst')) %&gt;% \n  filter(titleType == \"tvSeries\") %&gt;% \n  select(parentTconst,originalTitle) %&gt;% \n  distinct(parentTconst, .keep_all = TRUE)\n  \nepisodes_ranked &lt;- TITLE_EPISODES %&gt;% \n  left_join(TITLE_BASICS, by = 'tconst') %&gt;% #\n  inner_join(TITLE_RATINGS, by = 'tconst') %&gt;%\n  inner_join(series_name, by = \"parentTconst\") %&gt;% \n  filter(numVotes &gt; 200000 & averageRating == 10) %&gt;% \n  rename(show_name = originalTitle.y)\nepisodes_ranked %&gt;% select(primaryTitle,show_name,averageRating)\n\n\n  primaryTitle    show_name averageRating\n1   Ozymandias Breaking Bad            10\n\n\nUsing the left join in the first statement we can assure that we get the column we need to do the join with series_name data frame and the other inner_join’s allow us to only get the matching data. The answer to this question is no surprise to me being a huge Breaking Bad fan.\n\n\n\n\n\nShow the code\nNAME_BASICS |&gt; \n  separate_longer_delim(knownForTitles, \",\") %&gt;% \n  filter(primaryName == \"Mark Hamill\") %&gt;%\n  inner_join(TITLE_BASICS,by = c('knownForTitles' = 'tconst')) %&gt;% \n  select(primaryName,primaryTitle)\n\n\n  primaryName                                   primaryTitle\n1 Mark Hamill             Star Wars: Episode IV - A New Hope\n2 Mark Hamill        Star Wars: Episode VIII - The Last Jedi\n3 Mark Hamill Star Wars: Episode V - The Empire Strikes Back\n4 Mark Hamill     Star Wars: Episode VI - Return of the Jedi\n\n\nUsing an inner join after separating the known for column into unique cells allows us to see exactly what movies Hamill is best known for. We that it is the original Star wars films.\n\n\n\nAnswering this question requires some more joining as previously done as well as a statement that counts episodes per show and filters based a count greater than 12. Along with this i’ve also applied a dense_rank function. This ranks the averages, while also accounting for shows that have equal rating. The highest ranked shows under these conditions have a 9.7, and you can see from the dense rank the is a few shows with that rating. The interesting part is that Breaking Bad is ranked in 3rd position. I believe this to be because the greater than 12 episodes condition allows some obscure shows to be introduced. Lets change that number to 60 and see the results.\n\n\n\n\nShow the code\ntv_ranked&lt;- TITLE_EPISODES %&gt;%\n   inner_join(TITLE_RATINGS, by = c('parentTconst'='tconst')) %&gt;%\n   inner_join(TITLE_BASICS, by = c('parentTconst' = 'tconst')) %&gt;% \n   group_by(parentTconst) %&gt;% \n   filter(n()&gt;12) %&gt;% \n   ungroup() %&gt;% \n   select(primaryTitle,averageRating) %&gt;%\n   distinct(primaryTitle, .keep_all = TRUE) %&gt;% \n   mutate(rank = dense_rank(desc(averageRating))) %&gt;% \n   arrange(rank)\nDT::datatable(tv_ranked %&gt;% head(35),filter = 'top', options = list(\n  pageLength = 5))\n\n\n\n\n\n\n\n\n\nChanging the count to 60 did not seem to make a significant difference to 20 rows, and the first page as well as, the main answer are unchanged.\n\n\n\n\nThe best way to answer this question is to see the relation graphically. After making the data frame below we can use that to create 2 plots, one to display the average for each episode and one to display the season average for a cleaner distinction of relation.\n\n\nShow the code\nhappy_days&lt;- TITLE_EPISODES %&gt;%\n  inner_join(TITLE_RATINGS, by = c('tconst'='tconst')) %&gt;%\n  inner_join(TITLE_BASICS, by = c('parentTconst' = 'tconst')) %&gt;% \n  filter(primaryTitle == 'Happy Days') %&gt;% \n  mutate(season_episode= str_c(seasonNumber,episodeNumber, sep = \",\")) %&gt;%\n  select(averageRating,season_episode,seasonNumber,episodeNumber) %&gt;% \n  arrange(seasonNumber,episodeNumber) %&gt;% \n  group_by(seasonNumber) %&gt;% \n  mutate(season_average = mean(averageRating))\n\nggplot(happy_days, aes(x = season_episode, y = averageRating)) +\n  geom_point(size = 2.5,color = \"purple\") +\n  labs(title = \"Average Ratings of Happy Days Episodes\",\n       y = \"Average Rating\", x = \"Show Timeline\") +\n  theme_bw() +\n  theme(axis.text.x = element_blank())\n\n\n\n\n\n\n\n\n\nSeems like there might be a downward trend.\n\n\nShow the code\nggplot(happy_days, aes(x = seasonNumber, y = season_average)) +\n  geom_point(size = 2.5, color = \"purple\") +\n  geom_smooth(se = FALSE)+\n  labs(title = \"Average Ratings of Happy Days by Season\",\n       y = \"Average Rating\", x = \"Season Number\") +\n  theme_bw()\n\n\n\n\n\n\n\n\n\nThe above chart shows more clearly that were was a decline in rating as the show went on it was trending upwards towards the last few seasons. This indicates the show runners might have caught on to declining ratings and made changes to account for it.\n\n\n\n\nShow the code\nsmooth_vals = predict(loess(season_average~seasonNumber,happy_days))\n \nggplot(happy_days, aes(x = seasonNumber, y = season_average)) +\n  geom_point(size = 4, color = \"purple\") +\n  geom_line(aes(y = smooth_vals), colour = \"darkblue\",linewidth = 2,linetype = 'dotdash') +\n  labs(title = \"Average Ratings of Happy Days by Season\", y = \"Average Rating\", x = \"Season Number\") +\n  theme_bw() +\n  theme(axis.text.x = element_blank()) +\n  transition_reveal(seasonNumber) +\n  ease_aes('linear')"
  },
  {
    "objectID": "MP02.html#introduction",
    "href": "MP02.html#introduction",
    "title": "Mini Project#2 - Hollywood Analysis",
    "section": "",
    "text": "fkd aafnlfnDN\n\n\nSince the data is very large we will need to reduce the size of the data by filtering out the information that is not useful for analysis. We can do this by removing people with less than 2 “known for” title credits and also removing rare movies with less than 100 ratings.\n\n\nShow the code\nlibrary(ggplot2)\nTITLE_RATINGS |&gt;\n    ggplot(aes(x=numVotes)) + \n    geom_histogram(bins=30) +\n    xlab(\"Number of IMDB Ratings\") + \n    ylab(\"Number of Titles\") + \n    ggtitle(\"Majority of IMDB Titles Have Less than 100 Ratings\") + \n    theme_bw() + \n    scale_x_log10(label=scales::comma) + \n    scale_y_continuous(label=scales::comma)\n\n\n\n\n\n\n\n\n\nThe graph above is a great representation of the distribution of the our movie data with number of ratings as a descriptor. Showcases how a significant chunk of our date has a number of ratings that is less than 100.\n\n\n\n\n\nShow the code\nlibrary(stringr)\nlibrary(dplyr)\nNAME_BASICS &lt;- NAME_BASICS |&gt; \n  filter(str_count(knownForTitles, \",\") &gt; 1) #filtering the known for titles\n#removing those titles that have less than 100 ratings\n\nTITLE_RATINGS &lt;- TITLE_RATINGS |&gt;\n    filter(numVotes &gt;= 100)\n# now using this to reduced date to filter all the other tables with semi_join \nTITLE_BASICS &lt;- TITLE_BASICS |&gt;\n    semi_join(TITLE_RATINGS, \n              join_by(tconst == tconst))\n\nTITLE_CREW &lt;- TITLE_CREW |&gt;\n    semi_join(TITLE_RATINGS, \n              join_by(tconst == tconst))\n\nTITLE_EPISODES_1 &lt;- TITLE_EPISODES |&gt;\n    semi_join(TITLE_RATINGS, \n              join_by(tconst == tconst))\nTITLE_EPISODES_2 &lt;- TITLE_EPISODES |&gt;\n    semi_join(TITLE_RATINGS, \n              join_by(parentTconst == tconst))\n\nTITLE_EPISODES &lt;- bind_rows(TITLE_EPISODES_1,\n                            TITLE_EPISODES_2) |&gt;\n    distinct()\n\nTITLE_PRINCIPALS &lt;- TITLE_PRINCIPALS |&gt;\n    semi_join(TITLE_RATINGS, join_by(tconst == tconst))\n\nrm(TITLE_EPISODES_1)\nrm(TITLE_EPISODES_2)\n\n\nThe code above uses a semi-join to filter the other tables, ensuring that they only retain rows with keys that match those in the initial table without actually joining any tables together.\n\n\n\nMost of the time, data will contain many discrepancies. In the case of this data the source used the character \\\\N to representing a missing value within numeric columns. This raises two problems, firstly R does not recognize \\\\N as null, and the columns that should be numeric are in the string format. We can fix both by using as.numeric , which will convert the columns into numeric and also turn unrecognized strings into NAs.\n\n\nShow the code\n### Cleaning the data ####\nglimpse(TITLE_BASICS)\n\n\nRows: 374,145\nColumns: 9\n$ tconst         &lt;chr&gt; \"tt0000001\", \"tt0000002\", \"tt0000003\", \"tt0000004\", \"tt…\n$ titleType      &lt;chr&gt; \"short\", \"short\", \"short\", \"short\", \"short\", \"short\", \"…\n$ primaryTitle   &lt;chr&gt; \"Carmencita\", \"Le clown et ses chiens\", \"Poor Pierrot\",…\n$ originalTitle  &lt;chr&gt; \"Carmencita\", \"Le clown et ses chiens\", \"Pauvre Pierrot…\n$ isAdult        &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ startYear      &lt;chr&gt; \"1894\", \"1892\", \"1892\", \"1892\", \"1893\", \"1894\", \"1894\",…\n$ endYear        &lt;chr&gt; \"\\\\N\", \"\\\\N\", \"\\\\N\", \"\\\\N\", \"\\\\N\", \"\\\\N\", \"\\\\N\", \"\\\\N\",…\n$ runtimeMinutes &lt;chr&gt; \"1\", \"5\", \"5\", \"12\", \"1\", \"1\", \"1\", \"1\", \"45\", \"1\", \"1\"…\n$ genres         &lt;chr&gt; \"Documentary,Short\", \"Animation,Short\", \"Animation,Come…\n\n\nShow the code\nprint(\"________________\")\n\n\n[1] \"________________\"\n\n\nShow the code\nglimpse(TITLE_EPISODES)\n\n\nRows: 3,022,865\nColumns: 4\n$ tconst        &lt;chr&gt; \"tt0045960\", \"tt0046855\", \"tt0048378\", \"tt0048562\", \"tt0…\n$ parentTconst  &lt;chr&gt; \"tt0044284\", \"tt0046643\", \"tt0047702\", \"tt0047768\", \"tt0…\n$ seasonNumber  &lt;chr&gt; \"2\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"1\", \"3\", \"3\", \"…\n$ episodeNumber &lt;chr&gt; \"3\", \"4\", \"6\", \"10\", \"4\", \"20\", \"5\", \"2\", \"20\", \"6\", \"2\"…\n\n\nShow the code\nNAME_BASICS &lt;- NAME_BASICS |&gt;\n    mutate(birthYear = as.numeric(birthYear),\n           deathYear = as.numeric(deathYear)) # using the as numeric to force non-numeric into actual N/A instead of the \\\\N.R provides by the data\n\n\nWarning: There were 2 warnings in `mutate()`.\nThe first warning was:\nℹ In argument: `birthYear = as.numeric(birthYear)`.\nCaused by warning:\n! NAs introduced by coercion\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\n\nShow the code\nTITLE_BASICS &lt;- TITLE_BASICS |&gt;\n    mutate(startYear = as.numeric(startYear),\n           endYear = as.numeric(endYear),\n           isAdult = as.logical(isAdult))\n\n\nWarning: There were 2 warnings in `mutate()`.\nThe first warning was:\nℹ In argument: `startYear = as.numeric(startYear)`.\nCaused by warning:\n! NAs introduced by coercion\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\n\nShow the code\nTITLE_EPISODES &lt;- TITLE_EPISODES |&gt;\n    mutate(seasonNumber = as.numeric(seasonNumber),\n           episodeNumber = as.numeric(episodeNumber))\n\n\nWarning: There were 2 warnings in `mutate()`.\nThe first warning was:\nℹ In argument: `seasonNumber = as.numeric(seasonNumber)`.\nCaused by warning:\n! NAs introduced by coercion\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\n\nOur data also contains rows that have multiple values per cell. Separating these into their own rows will allow us to do a more detailed analysis later on. The code below does exactly that.\n\n\nShow the code\nNAME_BASICS |&gt; separate_longer_delim(knownForTitles, \",\") |&gt; slice_head(n=10)\n\n\n      nconst     primaryName birthYear deathYear\n1  nm0000001    Fred Astaire      1899      1987\n2  nm0000001    Fred Astaire      1899      1987\n3  nm0000001    Fred Astaire      1899      1987\n4  nm0000001    Fred Astaire      1899      1987\n5  nm0000002   Lauren Bacall      1924      2014\n6  nm0000002   Lauren Bacall      1924      2014\n7  nm0000002   Lauren Bacall      1924      2014\n8  nm0000002   Lauren Bacall      1924      2014\n9  nm0000003 Brigitte Bardot      1934        NA\n10 nm0000003 Brigitte Bardot      1934        NA\n                    primaryProfession knownForTitles\n1        actor,miscellaneous,producer      tt0050419\n2        actor,miscellaneous,producer      tt0072308\n3        actor,miscellaneous,producer      tt0053137\n4        actor,miscellaneous,producer      tt0027125\n5  actress,soundtrack,archive_footage      tt0037382\n6  actress,soundtrack,archive_footage      tt0075213\n7  actress,soundtrack,archive_footage      tt0117057\n8  actress,soundtrack,archive_footage      tt0038355\n9   actress,music_department,producer      tt0057345\n10  actress,music_department,producer      tt0049189\n\n\n\n\n\n\n\nTo answer this question we can first find out which table provides the answer efficiently. Looking at the tables, TITLE_BASICS seems to contain the most relevant information. By first using the Unique function on the title type column, we can see how best to filter our data to count each category.\n\n\nShow the code\n  unique(TITLE_BASICS$titleType)\n\n\n [1] \"short\"        \"movie\"        \"tvSeries\"     \"tvShort\"      \"tvMovie\"     \n [6] \"tvEpisode\"    \"tvMiniSeries\" \"video\"        \"tvSpecial\"    \"videoGame\"   \n\n\nThis shows us all the categories in the column and how to properly query them without scrolling through hundreds of rows of data. This shows some interesting information like the video game category which you wouldn’t expect to see on a film database\n\n\nShow the code\ncat(\"Number of Movies in Data:\",  TITLE_BASICS %&gt;% filter(titleType == \"movie\") %&gt;% summarise(count = n()) %&gt;% pull(count),\"\\n\") \n\n\nNumber of Movies in Data: 132220 \n\n\nShow the code\ncat(\"Number of TV Series:\", TITLE_BASICS %&gt;% filter(titleType == \"tvSeries\") %&gt;% summarise(count = n()) %&gt;% pull(count),\"\\n\")\n\n\nNumber of TV Series: 29986 \n\n\nShow the code\ncat(\"Number of TV episodes:\", TITLE_BASICS %&gt;% filter(titleType == \"tvEpisode\") %&gt;% summarise(count = n()) %&gt;% pull(count))\n\n\nNumber of TV episodes: 156725\n\n\n\n\n\nIn order to get an accurate answer, and basing it mostly on the data at hand we must use the filter function for living people and getting the minimum birth year that makes sense. This assumes that the death date is in fact accurate and is a death date. Something to note is that at least one group of people is listed in this table, under the name Cherry Bullet with a death date of 2024. This data point is misleading as this is not a single person but a KPOP group, and the death date is the date the band separated.\n\n\nShow the code\nNAME_BASICS %&gt;% filter(is.na(deathYear),!is.na(birthYear), 2024-birthYear &lt;= 100) %&gt;% arrange(birthYear) %&gt;% head(10)\n\n\n      nconst              primaryName birthYear deathYear\n1  nm0001693          Eva Marie Saint      1924        NA\n2  nm0011140                Lee Adams      1924        NA\n3  nm0021786         Humberto Almazán      1924        NA\n4  nm0073561        Yuriy Berenshteyn      1924        NA\n5  nm0080310 Harsukh Jagneshwar Bhatt      1924        NA\n6  nm0084762          Bo Bjelfvenstam      1924        NA\n7  nm0097155            Carola Bornée      1924        NA\n8  nm0106849            Pietro Bregni      1924        NA\n9  nm0121557             Michael Burk      1924        NA\n10 nm0130807          Hillevi Calvert      1924        NA\n                      primaryProfession\n1           actress,producer,soundtrack\n2  music_department,actor,miscellaneous\n3                                 actor\n4                       cinematographer\n5  director,assistant_director,producer\n6              director,writer,producer\n7                              producer\n8                              producer\n9                 actor,writer,director\n10                    script_department\n                               knownForTitles\n1     tt0047296,tt0053125,tt0348150,tt1837709\n2     tt0423977,tt0112605,tt6294822,tt0131369\n3     tt0050144,tt0249863,tt0223581,tt0244475\n4               tt0057509,tt8157292,tt9066040\n5     tt0156724,tt0156556,tt0156995,tt0156718\n6  tt26241720,tt32591822,tt14358988,tt7075484\n7    tt4493588,tt0051094,tt10250868,tt0048404\n8     tt0141673,tt0094787,tt0101493,tt0075845\n9     tt0312036,tt0054327,tt0048565,tt0048402\n10    tt0039315,tt0038385,tt0036884,tt0037544\n\n\nThis code finds all the people with missing death dates and also filters for and age max of 100. Any list of data with a calculated age more than this not only starts to become unreasonable but also fails to be true after a quick Google search. Using this method we get Eva Marie Saint.\n\n\n\n\nTo answer this we will need to do a couple of join statements.\n\n\nShow the code\nseries_name &lt;- TITLE_EPISODES %&gt;% #allows us to get the name of show,not just episode\n  inner_join(TITLE_BASICS, by = c('parentTconst' = 'tconst')) %&gt;% \n  filter(titleType == \"tvSeries\") %&gt;% \n  select(parentTconst,originalTitle) %&gt;% \n  distinct(parentTconst, .keep_all = TRUE)\n  \nepisodes_ranked &lt;- TITLE_EPISODES %&gt;% \n  left_join(TITLE_BASICS, by = 'tconst') %&gt;% #\n  inner_join(TITLE_RATINGS, by = 'tconst') %&gt;%\n  inner_join(series_name, by = \"parentTconst\") %&gt;% \n  filter(numVotes &gt; 200000 & averageRating == 10) %&gt;% \n  rename(show_name = originalTitle.y)\nepisodes_ranked %&gt;% select(primaryTitle,show_name,averageRating)\n\n\n  primaryTitle    show_name averageRating\n1   Ozymandias Breaking Bad            10\n\n\nUsing the left join in the first statement we can assure that we get the column we need to do the join with series_name data frame and the other inner_join’s allow us to only get the matching data. The answer to this question is no surprise to me being a huge Breaking Bad fan.\n\n\n\n\n\nShow the code\nNAME_BASICS |&gt; \n  separate_longer_delim(knownForTitles, \",\") %&gt;% \n  filter(primaryName == \"Mark Hamill\") %&gt;%\n  inner_join(TITLE_BASICS,by = c('knownForTitles' = 'tconst')) %&gt;% \n  select(primaryName,primaryTitle)\n\n\n  primaryName                                   primaryTitle\n1 Mark Hamill             Star Wars: Episode IV - A New Hope\n2 Mark Hamill        Star Wars: Episode VIII - The Last Jedi\n3 Mark Hamill Star Wars: Episode V - The Empire Strikes Back\n4 Mark Hamill     Star Wars: Episode VI - Return of the Jedi\n\n\nUsing an inner join after separating the known for column into unique cells allows us to see exactly what movies Hamill is best known for. We that it is the original Star wars films.\n\n\n\nAnswering this question requires some more joining as previously done as well as a statement that counts episodes per show and filters based a count greater than 12. Along with this i’ve also applied a dense_rank function. This ranks the averages, while also accounting for shows that have equal rating. The highest ranked shows under these conditions have a 9.7, and you can see from the dense rank the is a few shows with that rating. The interesting part is that Breaking Bad is ranked in 3rd position. I believe this to be because the greater than 12 episodes condition allows some obscure shows to be introduced. Lets change that number to 60 and see the results.\n\n\n\n\nShow the code\ntv_ranked&lt;- TITLE_EPISODES %&gt;%\n   inner_join(TITLE_RATINGS, by = c('parentTconst'='tconst')) %&gt;%\n   inner_join(TITLE_BASICS, by = c('parentTconst' = 'tconst')) %&gt;% \n   group_by(parentTconst) %&gt;% \n   filter(n()&gt;12) %&gt;% \n   ungroup() %&gt;% \n   select(primaryTitle,averageRating) %&gt;%\n   distinct(primaryTitle, .keep_all = TRUE) %&gt;% \n   mutate(rank = dense_rank(desc(averageRating))) %&gt;% \n   arrange(rank)\nDT::datatable(tv_ranked %&gt;% head(35),filter = 'top', options = list(\n  pageLength = 5))\n\n\n\n\n\n\n\n\n\nChanging the count to 60 did not seem to make a significant difference to 20 rows, and the first page as well as, the main answer are unchanged.\n\n\n\n\nThe best way to answer this question is to see the relation graphically. After making the data frame below we can use that to create 2 plots, one to display the average for each episode and one to display the season average for a cleaner distinction of relation.\n\n\nShow the code\nhappy_days&lt;- TITLE_EPISODES %&gt;%\n  inner_join(TITLE_RATINGS, by = c('tconst'='tconst')) %&gt;%\n  inner_join(TITLE_BASICS, by = c('parentTconst' = 'tconst')) %&gt;% \n  filter(primaryTitle == 'Happy Days') %&gt;% \n  mutate(season_episode= str_c(seasonNumber,episodeNumber, sep = \",\")) %&gt;%\n  select(averageRating,season_episode,seasonNumber,episodeNumber) %&gt;% \n  arrange(seasonNumber,episodeNumber) %&gt;% \n  group_by(seasonNumber) %&gt;% \n  mutate(season_average = mean(averageRating))\n\nggplot(happy_days, aes(x = season_episode, y = averageRating)) +\n  geom_point(size = 2.5,color = \"purple\") +\n  labs(title = \"Average Ratings of Happy Days Episodes\",\n       y = \"Average Rating\", x = \"Show Timeline\") +\n  theme_bw() +\n  theme(axis.text.x = element_blank())\n\n\n\n\n\n\n\n\n\nSeems like there might be a downward trend.\n\n\nShow the code\nggplot(happy_days, aes(x = seasonNumber, y = season_average)) +\n  geom_point(size = 2.5, color = \"purple\") +\n  geom_smooth(se = FALSE)+\n  labs(title = \"Average Ratings of Happy Days by Season\",\n       y = \"Average Rating\", x = \"Season Number\") +\n  theme_bw()\n\n\n\n\n\n\n\n\n\nThe above chart shows more clearly that were was a decline in rating as the show went on it was trending upwards towards the last few seasons. This indicates the show runners might have caught on to declining ratings and made changes to account for it.\n\n\n\n\nShow the code\nsmooth_vals = predict(loess(season_average~seasonNumber,happy_days))\n \nggplot(happy_days, aes(x = seasonNumber, y = season_average)) +\n  geom_point(size = 4, color = \"purple\") +\n  geom_line(aes(y = smooth_vals), colour = \"darkblue\",linewidth = 2,linetype = 'dotdash') +\n  labs(title = \"Average Ratings of Happy Days by Season\", y = \"Average Rating\", x = \"Season Number\") +\n  theme_bw() +\n  theme(axis.text.x = element_blank()) +\n  transition_reveal(seasonNumber) +\n  ease_aes('linear')"
  },
  {
    "objectID": "MP02.html#task-3",
    "href": "MP02.html#task-3",
    "title": "Mini Project#2 - Hollywood Analysis",
    "section": "Task 3",
    "text": "Task 3"
  }
]